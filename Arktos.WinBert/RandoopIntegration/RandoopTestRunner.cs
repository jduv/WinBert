namespace Arktos.WinBert.RandoopIntegration
{
    using AppDomainToolkit;
    using Arktos.WinBert.Instrumentation;
    using Arktos.WinBert.Testing;
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Reflection;

    /// <summary>
    /// Executes a suite of tests generated by Randoop.
    /// </summary>
    public class RandoopTestRunner : ITestRunner
    {
        #region Fields & Constants

        private readonly string testMethodName;
        private readonly IList<Xml.DumpIgnoreTarget> ignoreTargets;

        #endregion

        #region Constructors & Destructors

        public RandoopTestRunner(string testMethodName, IList<Xml.DumpIgnoreTarget> ignoreTargets = null)
        {
            if (string.IsNullOrWhiteSpace(testMethodName))
            {
                throw new ArgumentException("Test method name cannot be null or whitespace!");
            }

            this.testMethodName = testMethodName;
            this.ignoreTargets = ignoreTargets;
        }

        #endregion

        #region Public Methods

        /// <inheritdoc />
        public ITestRunResult RunTests(IAssemblyTarget target, IAssemblyTarget tests)
        {
            ITestRunResult result;

            try
            {
                // Load tests and target
                var loader = new AssemblyLoader();
                loader.LoadAssemblyWithReferences(LoadMethod.LoadFrom, target.Location);
                var testAssembly = loader.LoadAssembly(LoadMethod.LoadFrom, tests.Location);

                // Grab the reflection wrapper.
                var testUtilReflectionWrapper = new TestUtilReflectionWrapper(loader);

                // If we have ignore targets, set up the appropriate test state recorder.
                if (this.ignoreTargets != null && this.ignoreTargets.Any())
                {
                    testUtilReflectionWrapper.InvokeStateRecorderPropertySet(this.BuildTestStateRecorder());
                }

                // Execute the tests.
                foreach (var type in testAssembly.GetTypes())
                {
                    var testObj = Activator.CreateInstance(type);
                    var method = type.GetMethods().First(x => x.Name.Equals(this.testMethodName));
                    method.Invoke(testObj, null);
                }

                // Execute Save by finding the loaded winbert assembly and calling TestUtil.SaveResults()
                var analysisLogPath = CreateAnalysisFilePath(target, tests);
                testUtilReflectionWrapper.InvokeSaveResults(analysisLogPath);
                result = TestRunResult.Successful(analysisLogPath, target);
            }
            catch (Exception)
            {
                result = TestRunResult.Failure(target);
            }

            return result;
        }

        #endregion

        #region Private Methods

        /// <summary>
        /// Creates a file path for the analysis file from the assembly target.
        /// </summary>
        /// <param name="target">
        /// The assembly target to create the analysis file path for.
        /// </param>
        /// <param name="tests">
        /// The tests.
        /// </param>
        /// <returns>
        /// A string path to an XML file that should contain analysis information.
        /// </returns>
        private static string CreateAnalysisFilePath(IAssemblyTarget target, IAssemblyTarget tests)
        {
            var endingIdx = tests.Location.LastIndexOf(".instrumented.dll");
            var uniqueId = tests.Location.Substring(endingIdx - 7, 7);
            var analysisFileName = Path.GetFileName(target.Location);
            var extension = Path.GetExtension(analysisFileName);
            analysisFileName = Path.ChangeExtension(analysisFileName, extension + "." + uniqueId + ".analysis.xml");
            return Path.Combine(Path.GetDirectoryName(target.Location), analysisFileName);
        }

        /// <summary>
        /// Builds the <see cref="ITestStateRecorder"/> implementation that will be used to dump
        /// information on the tests by the <see cref="TestUil"/> instance.
        /// </summary>
        /// <returns>
        /// The correct <see cref="ITestStateRecorder"/> implementation.
        /// </returns>
        private ITestStateRecorder BuildTestStateRecorder()
        {
            var methodDumper = new MethodCallDumper(new ObjectDumper(this.ignoreTargets));
            return new TestStateRecorder(methodDumper);
        }

        #endregion

        #region Private Classes

        /// <summary>
        /// Simple innner class to represent a wrapped TestUtil type instance. Allows for invocation of 
        /// some of the methods via reflection.
        /// </summary>
        private class TestUtilReflectionWrapper
        {
            private readonly Type testUtil;

            #region Constructors & Destructors

            public TestUtilReflectionWrapper(AssemblyLoader loader)
            {
                if (loader == null)
                {
                    throw new ArgumentNullException("loader");
                }

                var winbert = loader.GetAssemblies().FirstOrDefault(x => x.FullName.Equals(Assembly.GetExecutingAssembly().FullName));
                this.testUtil = winbert == null ? null : winbert.GetTypes().FirstOrDefault(x => x.Name.Equals(typeof(TestUtil).Name));

                // Rut ro.
                if (testUtil == null)
                {
                    throw new ArgumentException("Unable to find the type TestUtil in the passed assembly loader.");
                }

                // Set props
                this.SaveResults = this.testUtil.GetMethod(TestUtilMethodInjector.SaveResultsName);
                var stateRecorderProp = this.testUtil.GetProperty(TestUtilMethodInjector.StateRecorderPropName);
                this.StateRecorderPropGetter = stateRecorderProp.GetGetMethod();
                this.StateRecorderPropSetter = stateRecorderProp.GetSetMethod();
            }

            #endregion

            #region Properties

            /// <summary>
            /// Gets the SaveResults method info.
            /// </summary>
            public MethodInfo SaveResults { get; private set; }

            /// <summary>
            /// Gets the getter for the <see cref="TestUtil.StateRecorder"/> property.
            /// </summary>
            public MethodInfo StateRecorderPropGetter { get; private set; }

            /// <summary>
            /// Gets the setter for the <see cref="TestUtil.StateRecorder"/> property.
            /// </summary>
            public MethodInfo StateRecorderPropSetter { get; private set; }

            #endregion

            #region Public Methods

            /// <summary>
            /// Invokes the SaveResults method on the wrapped <see cref="TestUtil"/> type passing it the given path.
            /// </summary>
            /// <param name="path">
            /// The path to pass to the invocation of <see cref="TestUtil.SaveResults"/>
            /// </param>
            public void InvokeSaveResults(string path)
            {
                this.SaveResults.Invoke(testUtil, new object[] { path });
            }

            /// <summary>
            /// Invokes the getter for the state recorder property on the wrapped <see cref="TestUtil"/> type.
            /// </summary>
            /// <returns>
            /// The currently set <see cref="ITestStateRecorder"/> implementation for the wrapped <see cref="TestUtil"/> type.
            /// </returns>
            public ITestStateRecorder InvokeStateRecorderPropertyGet()
            {
                return this.StateRecorderPropGetter.Invoke(this.testUtil, null) as ITestStateRecorder;
            }

            /// <summary>
            /// Invokes the setter for the state recorder property on the wrapped <see cref="TestUtil"/> type.
            /// </summary>
            /// <param name="toSet">
            /// The value to set.
            /// </param>
            public void InvokeStateRecorderPropertySet(ITestStateRecorder toSet)
            {
                this.StateRecorderPropSetter.Invoke(this.testUtil, new object[] { toSet });
            }

            #endregion
        }

        #endregion
    }
}